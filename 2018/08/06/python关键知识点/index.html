<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="char369@hotmail.com">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python," />










<meta name="description" content="Python基础数据类型 整数(1,-100,无大小限制)、浮点数(12.12,3.14,-0.25)、字符串(‘’,””)、布尔类型(True,False)、空值(None)  字符串编码 encode(‘utf-8’) 指定方式字符串编码：编码转换decode(‘utf-8’) 用指定方式自负解码：byte转 strlen(‘abcd’) = 4 包含字符个数 格式化字符串1.’my nam">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python关键知识点">
<meta property="og:url" content="http://yoursite.com/2018/08/06/python关键知识点/index.html">
<meta property="og:site_name" content="Charl Blog">
<meta property="og:description" content="Python基础数据类型 整数(1,-100,无大小限制)、浮点数(12.12,3.14,-0.25)、字符串(‘’,””)、布尔类型(True,False)、空值(None)  字符串编码 encode(‘utf-8’) 指定方式字符串编码：编码转换decode(‘utf-8’) 用指定方式自负解码：byte转 strlen(‘abcd’) = 4 包含字符个数 格式化字符串1.’my nam">
<meta property="og:locale" content="char369@hotmail.com">
<meta property="og:updated_time" content="2018-08-18T15:19:26.271Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python关键知识点">
<meta name="twitter:description" content="Python基础数据类型 整数(1,-100,无大小限制)、浮点数(12.12,3.14,-0.25)、字符串(‘’,””)、布尔类型(True,False)、空值(None)  字符串编码 encode(‘utf-8’) 指定方式字符串编码：编码转换decode(‘utf-8’) 用指定方式自负解码：byte转 strlen(‘abcd’) = 4 包含字符个数 格式化字符串1.’my nam">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/06/python关键知识点/"/>





  <title>Python关键知识点 | Charl Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="char369@hotmail.com">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Charl Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">charl's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/python关键知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="charl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Charl Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python关键知识点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-06T21:01:38+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>整数(1,-100,无大小限制)、浮点数(12.12,3.14,-0.25)、字符串(‘’,””)、布尔类型(True,False)、空值(None)</p>
</blockquote>
<h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><blockquote>
<p>encode(‘utf-8’) 指定方式字符串编码：编码转换<br>decode(‘utf-8’) 用指定方式自负解码：byte转 str<br>len(‘abcd’) = 4 包含字符个数<br> 格式化字符串<br>1.’my name is %s,and is %d years old’ % (‘Charl’,25)<br>%d 整数，%f 浮点数 %s 字符串 %x 十六进制（一般都用%s）</p>
<p>2.format()<br>‘my name is {0},and is {1} years old’.format(‘charl’,18)</p>
</blockquote>
<h3 id="列表：List和Tuple"><a href="#列表：List和Tuple" class="headerlink" title="列表：List和Tuple"></a>列表：List和Tuple</h3><ul>
<li><p>list列表</p>
<blockquote>
<p>是一种有序的列表集合(元素的数据类型可不同)。用[]括起来表示，越界时会报IndexError错误<br>cities = [‘beijing’,’shanghai’,’nanjing’,’shenzhen’]<br>cities[2] — nanjing<br>list 可以用负数做索引，倒序取出数据<br>cities[-2] — nanjing<br>1.cities.append(‘wuhan’) 在List末尾追加元素<br>2.cities.insert(2,’chongqing’) 在指定位置插入元素，后面元素后移<br>3.cities.pop() 删除list末尾的元素<br>4.cities.pop(i) 删除i位置的元素<br>5.len(cities) 获取list元素个数<br>6.citiesp[1] = ‘lasa’</p>
</blockquote>
</li>
<li><p>tuple列表</p>
<blockquote>
<p>也是一种有序列表，tuple一旦初始化就不能修改，用()括起来表示。用tuple不可变，所以代码也更安全，所以，如果可能，能用tuple代替list就尽量用tuple。（当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来）<br>cities = (‘beijing’,’shanghai’,’nanjing’,’shenzhen’)<br>如果要定义只有一个元素的tuple，t = (‘one’,)避免歧义<br>索引和查询裂变跟list一样</p>
</blockquote>
</li>
<li><p>list高级操作</p>
<blockquote>
<p>1.切片：取指定索引范围的操作</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [&apos;Charl&apos;,&apos;Jone&apos;,&apos;Jack&apos;,&apos;Tom&apos;]</span><br><span class="line">&gt;&gt;&gt; arr[0:2] -- 表示从索引0开始，到索引2结束，不包括索引2的数据</span><br><span class="line">[&apos;Charl&apos;, &apos;Jone&apos;]</span><br><span class="line">&gt;&gt;&gt; arr[:2] -- 如果第一个索引是0，还可以省略</span><br><span class="line">[&apos;Charl&apos;, &apos;Jone&apos;]</span><br><span class="line">&gt;&gt;&gt; arr[-2:] -- 支持倒数切片</span><br><span class="line">[&apos;Jack&apos;, &apos;Tom&apos;]</span><br><span class="line">&gt;&gt;&gt; arr = list(range(100))</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[0, 1, 2, ...99]</span><br><span class="line">&gt;&gt;&gt; arr[:10] -- 取出前10个元素</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; arr[-10:] -- 取出后10个元素</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br><span class="line">&gt;&gt;&gt; arr[11:20] -- 取出11到20的元素</span><br><span class="line">[11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br><span class="line">&gt;&gt;&gt; arr[:10:2] -- 前10个数，每隔2个取一个</span><br><span class="line">[0, 2, 4, 6, 8]</span><br><span class="line">&gt;&gt;&gt; arr[::10] -- 所有数，每隔10个取一个</span><br><span class="line">[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</span><br><span class="line">&gt;&gt;&gt; arr[:] -- 复制一个list</span><br><span class="line">[0, 1, 2... 99]</span><br><span class="line"></span><br><span class="line">tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</span><br><span class="line">&gt;&gt;&gt; t1 = (list(range(5)))</span><br><span class="line">&gt;&gt;&gt; t1</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; t1[:3]</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">字符串&apos;xxx&apos;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串,Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</span><br><span class="line">&gt;&gt;&gt; &apos;yellow&apos;[:2]</span><br><span class="line">&apos;ye&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.迭代：遍历list或者dict,set<br>第一种是使用for…in 的方式，可以用for..in 遍历：list,tuple,dict,set,string,只要是可迭代对象都可以进行正常运行<br>怎么判断对象是否可迭代呢？通过collcetions的Iterable进行判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;,Iterable) # str可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123,Iterable) # 整数不可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.列表生成：list(range())</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x*x for x in range(1,9)] # 生成1-9的平方</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64]</span><br><span class="line">&gt;&gt;&gt; [x*x for x in range(1,9) if x % 2 == 0] #  仅仅取出偶数的平方</span><br><span class="line">[4, 16, 36, 64]</span><br><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] # 两层循环生成全排列</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;charl&apos;,&apos;age&apos;:18,&apos;city&apos;:&apos;nanjing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; for k,v in d.items():</span><br><span class="line">...     print(k,&apos;--&apos;,v)</span><br><span class="line">... </span><br><span class="line">name -- charl</span><br><span class="line">city -- nanjing</span><br><span class="line">age -- 18</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + str(v) for k,v in d.items()]</span><br><span class="line">[&apos;name=charl&apos;, &apos;city=nanjing&apos;, &apos;age=18&apos;]</span><br><span class="line"></span><br><span class="line">isinstance 可以判断一个变量是不是某个类型</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ul>
<li>if(注意别忘了:) conditon 如果是非0数值，非空字符串，非空list就判断为True,否则为False<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = input(&apos;money:&apos;);</span><br><span class="line">money = int(s);</span><br><span class="line">if money &gt;= 10000:</span><br><span class="line">    print(&apos;哇，土豪！！&apos;)</span><br><span class="line">elif money &gt;= 5000:</span><br><span class="line">    print(&apos;小日子过的可以啊&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;人穷，志不穷，加油&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>for…in循环<blockquote>
<p>range() 可以生成一个整数序列</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cities = [&apos;beijing&apos;,&apos;nanjing&apos;,&apos;shanghai&apos;]</span><br><span class="line">for city in cities:</span><br><span class="line">    print(city)</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">for i in range(10):</span><br><span class="line">    sum += i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<ul>
<li>while循环，只要条件满足就不断循环<blockquote>
<p>break:可以跳出循环<br>continue:跳过本次循环，直接开始下次循环</p>
</blockquote>
</li>
</ul>
<h3 id="字典dict和set"><a href="#字典dict和set" class="headerlink" title="字典dict和set"></a>字典dict和set</h3><ul>
<li>1.dict(dictionary)字典，类似于Java中的Map，使用key-value存储，查找速度很快。语法：{key:value} 一个key只能对应一个value。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;charl&apos;: 25,&apos;Tom&apos;: 33,&apos;Jerry&apos;: 18&#125;</span><br><span class="line">d[&apos;charl&apos;] = 18</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断key是否存在：<br>1.通过…in</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;kong&apos; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.通过dict的get()方法，key不存在返回None,或者一个自定义值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&apos;kong&apos;,&apos;bucunzai&apos;)</span><br><span class="line">&apos;bucunzai&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：返回None的时候Python的交互环境不显示结果。<br>删除数据：pop(key) 删除key和value</p>
<p>和list比较，dict有以下几个特点：</p>
</blockquote>
<blockquote>
<blockquote>
<p>查找和插入的速度极快，不会随着key的增加而变慢；<br>需要占用大量的内存，内存浪费多。</p>
<p>而list相反：</p>
<p>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。<br>所以，dict是用空间来换取时间的一种方法。</p>
</blockquote>
</blockquote>
<p><strong> dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</strong></p>
<blockquote>
<p>dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
</blockquote>
<blockquote>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p>
</blockquote>
<ul>
<li>2.Set 是一组key的集合(key不能重复)。创建set 需要用list作为数据集合：set()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = set([1,2,3,4,4,5])</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&gt;&gt;&gt; b.add(6)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;1, 2, 3, 4, 5, 6&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>add(key) 添加元素<br>remove(key) 删除元素<br><strong><em> set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2,3,4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</p>
</blockquote>
<h2 id="Python函数"><a href="#Python函数" class="headerlink" title="Python函数"></a>Python函数</h2><blockquote>
<p>python有很多内置的函数，可以供我们直接调用，可以在：<a href="http://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">http://docs.python.org/3/library/functions.html</a> 查看<br>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = abs</span><br><span class="line">&gt;&gt;&gt; c(-120)</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<ul>
<li>定义函数<blockquote>
<p>使用def 语句： def name(args): 执行到return或者执行完毕 就执行完了<br>from 模块名(文件名) import 函数名 ,导入函数<br>pass 表示什么都不做，相当于占位符</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def m_abs(x):</span><br><span class="line">...     if not isinstance(x,(int,float)):</span><br><span class="line">...         raise TypeError(&apos;类型错啦&apos;)</span><br><span class="line">...     if x &gt;= 0:</span><br><span class="line">...         return x</span><br><span class="line">...     else:</span><br><span class="line">...         return -x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; m_abs(-19)</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; m_abs(&apos;12312&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in m_abs</span><br><span class="line">TypeError: 类型错啦</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小结<br>定义函数时，需要确定函数名和参数个数；</p>
</blockquote>
<blockquote>
<p>如果有必要，可以先对参数的数据类型做检查；</p>
</blockquote>
<blockquote>
<p>函数体内部可以用return随时返回函数结果；</p>
</blockquote>
<blockquote>
<p>函数执行完毕也没有return语句时，自动return None。</p>
</blockquote>
<blockquote>
<p>函数可以同时返回多个值，但其实就是一个tuple</p>
</blockquote>
<ul>
<li>函数参数<blockquote>
<p>1.位置参数：下面的x,n就是位置参数（顾名思义,按照位置顺序传参，调用的时候必须按顺序全部传递）</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power1(x,n):</span><br><span class="line">...     s = 1</span><br><span class="line">...     while n &gt; 0:</span><br><span class="line">...         n = n - 1</span><br><span class="line">...         s = s * x</span><br><span class="line">...     return s</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; power1(2,3)</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.默认参数 下面的n 就是默认参数，参数一个默认值，能降低调用函数的难度(注：必选参数在前，默认参数在后；定义默认参数要牢记一点：默认参数必须指向不变对象！)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power(x,n=2):</span><br><span class="line">...     s = 1</span><br><span class="line">...     while n &gt; 0:</span><br><span class="line">...         n = n - 1</span><br><span class="line">...         s = s * x</span><br><span class="line">...     return s</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; power(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.可变参数 传入的参数个数是可变的，可以是0个、1个、2个到任意个<br>一种是参数才用list或者tuple这种数据结构 如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(numbers):</span><br><span class="line">...     sum = 0</span><br><span class="line">...     for n in numbers:</span><br><span class="line">...         sum += n*n</span><br><span class="line">...     return sum</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; add([2,3,4])</span><br><span class="line">29</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种是参数用:*args,(其实内部接受的还是tuple)如下,</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(*numbers):</span><br><span class="line">...     sum = 0 </span><br><span class="line">...     for n in numbers:</span><br><span class="line">...         sum += n * n</span><br><span class="line">...     return sum</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; add(2,3,4)</span><br><span class="line">29</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; nums = (1,2,3)</span><br><span class="line">&gt;&gt;&gt; add(*nums)</span><br><span class="line">14</span><br><span class="line">*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.关键字参数 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict，类似：**kw，代码如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def login(name,passwd,**kw):</span><br><span class="line">...     print(&apos;name:&apos;,name,&apos;passwd:&apos;,passwd,&apos;other:&apos;,kw)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; login(&apos;charl&apos;,&apos;123&apos;)</span><br><span class="line">name: charl passwd: 123 other: &#123;&#125;</span><br><span class="line">函数person除了必选参数name和age外，还接受关键字参数kw。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; login(&apos;charl&apos;,&apos;123&apos;,city=&apos;nanjing&apos;)</span><br><span class="line">name: charl passwd: 123 other: &#123;&apos;city&apos;: &apos;nanjing&apos;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;:&apos;nanjing&apos;,&apos;job&apos;:&apos;ceo&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; login(&apos;charl&apos;,&apos;123&apos;,**extra)</span><br><span class="line">name: charl passwd: 123 other: &#123;&apos;city&apos;: &apos;nanjing&apos;, &apos;job&apos;: &apos;ceo&apos;&#125;</span><br><span class="line"></span><br><span class="line">注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.命名关键字参数 顾名思义就是限制关键字参数的名字(命名关键字参数必须传入参数名)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def person(name,passwd,*,city,job):</span><br><span class="line">...     print(name,passwd,city,job)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; person(&apos;charl&apos;,&apos;123&apos;,city = &apos;nanjing&apos;,job = &apos;ceo&apos;)</span><br><span class="line">charl 123 nanjing ceo</span><br><span class="line"></span><br><span class="line">如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了</span><br><span class="line">&gt;&gt;&gt; def login(name,passwd,*args,city,job):</span><br><span class="line">...     print(name,passwd,args,city,job)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; login(&apos;charl&apos;,&apos;123&apos;,city = &apos;nanjing&apos;,job = &apos;ceo&apos;)</span><br><span class="line">charl 123 () nanjing ceo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：python中的必选参数、默认参数、可变参数、关键字参数和命名关键字是可以组合使用的。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<br>*args是可变参数，args接收的是一个tuple；</p>
</blockquote>
<blockquote>
<p>**kw是关键字参数，kw接收的是一个dict。</p>
</blockquote>
<ul>
<li>递归函数<blockquote>
<p>在函数内部调用自己,使用递归函数需要注意防止栈溢出,在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。<br>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况<br>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">河内塔问题:源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？</span><br><span class="line">&gt;&gt;&gt; def hanoi(number,p1,p2,p3):</span><br><span class="line">...     if number == 1:</span><br><span class="line">...         print(&apos;盘子从--&apos;,p1,&apos;--移动到--&apos;,p3,&apos;end&apos;)</span><br><span class="line">...     else:</span><br><span class="line">...         hanoi(number-1,p1,p3,p2)</span><br><span class="line">...         print(&apos;盘子从--&apos;,p1,&apos;--移动到--&apos;,p3,&apos;end&apos;)</span><br><span class="line">...         hanoi(number-1,p2,p1,p3)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; hanoi(3,&apos;柱子1&apos;,&apos;柱子2&apos;,&apos;柱子3&apos;)</span><br><span class="line">盘子从-- 柱子1 --移动到-- 柱子3 end</span><br><span class="line">盘子从-- 柱子1 --移动到-- 柱子2 end</span><br><span class="line">盘子从-- 柱子3 --移动到-- 柱子2 end</span><br><span class="line">盘子从-- 柱子1 --移动到-- 柱子3 end</span><br><span class="line">盘子从-- 柱子2 --移动到-- 柱子1 end</span><br><span class="line">盘子从-- 柱子2 --移动到-- 柱子3 end</span><br><span class="line">盘子从-- 柱子1 --移动到-- 柱子3 end</span><br></pre></td></tr></table></figure>
<h2 id="Python函数式编程"><a href="#Python函数式编程" class="headerlink" title="Python函数式编程"></a>Python函数式编程</h2><blockquote>
<p>它是一种面向过程的程序设计，但其思想更接近数学计算。</p>
</blockquote>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function abs&gt;</span><br><span class="line">&gt;&gt;&gt; f(-10)</span><br><span class="line">10</span><br><span class="line">#函数本身也可以赋值给变量，即：变量可以指向函数。函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数</span><br><span class="line"></span><br><span class="line">#既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。如下：f 传入的为abs函数</span><br><span class="line">&gt;&gt;&gt; def high(x,y,f):</span><br><span class="line">...     return f(x) + f(y)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; high(1,-20,abs)</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.map/reduce </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</span><br><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; r = map(f,[1,2,3,4,5])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">&lt;map object at 0x000001B5DBD546A0&gt;</span><br><span class="line"></span><br><span class="line">#reduce 主要作用在一个序列(列表)上，必须接受两个参数，主要是用来做累积计算。</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x,y):</span><br><span class="line">...     return x + y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; reduce(add,[1,2,3,4,5])</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line"># </span><br><span class="line">&gt;&gt;&gt; def fn(x,y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; reduce(fn,[1,2,3,4])</span><br><span class="line">1234</span><br><span class="line"># map/reduce混合使用</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; DIGITS = &#123;&apos;0&apos;:1,&apos;1&apos;:1,&apos;2&apos;:2,&apos;3&apos;:3,&apos;4&apos;:4,&apos;5&apos;:5,&apos;6&apos;:6,&apos;7&apos;:7,&apos;8&apos;:8,&apos;9&apos;:9&#125;</span><br><span class="line">&gt;&gt;&gt; def f(s):</span><br><span class="line">...     return DIGITS[s]</span><br><span class="line">&gt;&gt;&gt; def str2int(s):</span><br><span class="line">...     return reduce(lambda x,y:x*10 + y,map(f,s))</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; str2int(&apos;1234&apos;)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.filter() 用于过滤列表，也是接受两个参数，返回的是一个Iterator</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def filter1(n):</span><br><span class="line">...     return n % 2 == 0</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; list(filter(filter1,[1,2,4,5,8,9]))</span><br><span class="line">[2, 4, 8]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.sorted 排序：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([3,342,2341,32,2,5])</span><br><span class="line">[2, 3, 5, 32, 342, 2341]</span><br><span class="line">#它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序</span><br><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 返回的并不是求和结果，而是求和函数</span><br><span class="line"># 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</span><br><span class="line">#注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数</span><br><span class="line">#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def lazy_sum(*args):</span><br><span class="line">...     def sum():</span><br><span class="line">...         result = 0</span><br><span class="line">...         for n in args:</span><br><span class="line">...             result += n</span><br><span class="line">...         return result</span><br><span class="line">...     return sum</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; a = lazy_sum(1,2,3,54)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x000001B5DBF0E2F0&gt;</span><br><span class="line">&gt;&gt;&gt; a()</span><br><span class="line">60</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数-lambda表示"><a href="#匿名函数-lambda表示" class="headerlink" title="匿名函数 lambda表示"></a>匿名函数 lambda表示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</span><br><span class="line">&gt;&gt;&gt; list(map(lambda x : x * x,[1,2,3,4]))</span><br><span class="line">[1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<h3 id="装饰器-在代码运行期间动态增加功能-类似于Java中的代理模式"><a href="#装饰器-在代码运行期间动态增加功能-类似于Java中的代理模式" class="headerlink" title="装饰器 在代码运行期间动态增加功能(类似于Java中的代理模式)"></a>装饰器 在代码运行期间动态增加功能(类似于Java中的代理模式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def log(func):</span><br><span class="line">...     def wa(*args,**kw):</span><br><span class="line">...         print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">...         return func(*args,**kw)</span><br><span class="line">...     return wa</span><br><span class="line">... </span><br><span class="line"># 把@log放到now()函数的定义处，相当于执行了语句：now = log(now)</span><br><span class="line">&gt;&gt;&gt; @log</span><br><span class="line">... def now():</span><br><span class="line">...     print(&apos;二〇一八年八月八日 23:44:26&apos;)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">二〇一八年八月八日 23:44:26</span><br></pre></td></tr></table></figure>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># functools.partial就是帮助我们创建一个偏函数的</span><br><span class="line"># 它的作用就是把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;10000&apos;)</span><br><span class="line">16</span><br><span class="line">#当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</span><br></pre></td></tr></table></figure>
<h2 id="Python模块"><a href="#Python模块" class="headerlink" title="Python模块"></a>Python模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># python本身就内置了很多模块，只要安装好了，可以直接使用</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python3</span><br><span class="line"># 可以让文件可以在linux系统运行</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 指定文档编码使用标准utf-8</span><br><span class="line"></span><br><span class="line">&apos;a test module&apos;</span><br><span class="line">#表示当前模块(文件)的文档注释，何模块代码的第一个字符串都被视为模块的文档注释</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Charl.Wei&apos;</span><br><span class="line"># 固定写法，指定模块作者</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">#导入sys模块</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args) == 1:</span><br><span class="line">        print(&apos;Hello,World&apos;)</span><br><span class="line">    elif len(args) == 2:</span><br><span class="line">        print(&apos;Hello,%s&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many args&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<ul>
<li>作用域<br>python 中有很多函数和变量，这些函数和变量的作用域划分方式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#__xxx__(左右两个下划线)这样的变量是特殊变量，可以被直接引用，我们自己的变量一般不要用这种变量名,如：__author__,__name__,__doc__</span><br><span class="line">#用_前缀修饰的变量名一般是private的，不应该被直接引用,实际上还是可以调用到，只是这么约定</span><br></pre></td></tr></table></figure>
<ul>
<li>安装第三方模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Python中，安装第三方模块，是通过包管理工具pip完成的。pip install...</span><br><span class="line"></span><br><span class="line">也可以用Anaconda进行安装。</span><br><span class="line">默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&apos;&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&apos;, ..., &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>数据封装、继承和多态是面向对象的三大特点</p>
<ul>
<li><p>封装<br>在python中，前面讲的所有数据类型都可以视为对象，当然也可以自定义对象(也就是类Class)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#下面创建了一个学生的Class,有name和score两个属性，打印学生成绩的方法</span><br><span class="line"># 定义类是通过class关键字，后面跟类名(一般用大写开头字母),后面(object)表示从那个类继承过来，object是所有类的父类</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line"># 类是具有模版作用的，所以在定义类的创建方法的时候，可以把一些我们认为必须绑定的属写到__init__方法中，这个方法的第一个参数永远是self表示实例本身，self指向创建的实例本身，创建的时候self 不用传。</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"># 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self,并且调用时不需要传入，解释器会自己传入。</span><br><span class="line">#你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s:%s&apos; % (self.name,self.score))</span><br><span class="line">... ... ... ... ... ... </span><br><span class="line"># 下面bart是一个实例变量，它指向的就是一个Student实例(实际上保存的是一个指向对象的内存地址)</span><br><span class="line">&gt;&gt;&gt; bart = Student(&apos;Charl&apos;,100)</span><br><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Charl:100</span><br><span class="line"># 我们可以自由的给一个实例变量绑定属性</span><br><span class="line">&gt;&gt;&gt; bart.age = 18</span><br><span class="line">&gt;&gt;&gt; bart.age</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line"># 在属性名称前加两个下划线__，表示是私有变量，只能内部访问。</span><br><span class="line">#注:双划线开头的变量并不是真的不能访问，是因为Python解释器把__name变成了_Student__name,所以可以通过_Student__name来访问，但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    def __init__(self,name,score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s:%s&apos; % (self.__name,self.__score))</span><br><span class="line">... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; s1 = Student(&apos;Charl&apos;,100)</span><br><span class="line">&gt;&gt;&gt; s1.print_score()</span><br><span class="line">Charl:100</span><br><span class="line">&gt;&gt;&gt; s1.__name # 无法直接访问</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</span><br><span class="line"></span><br><span class="line"># 在Python中，变量名类似__xxx__的，也就是以双下划线开头和结尾的变量是特殊变量，可以直接访问。</span><br><span class="line"># 以一个下划线_开头的变量，外部还是可以访问的，‘虽然能访问，但是把它视为私有变量，不要随意访问’</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    def __init__(self,name,gender):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__gender = gender</span><br><span class="line">    def set_gender(self,gender):</span><br><span class="line">        if gender == &apos;男&apos; or gender == &apos;女&apos;:</span><br><span class="line">            self.__gender = gender</span><br><span class="line">        else:</span><br><span class="line">        # 抛出异常</span><br><span class="line">            raise ValueError(&apos;bad gender&apos;)</span><br><span class="line">    def get_gender(self):</span><br><span class="line">        return self.__gender</span><br><span class="line">... ... ... ... ... ... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; charl = Student(&apos;Charl&apos;,&apos;男&apos;)</span><br><span class="line">&gt;&gt;&gt; charl.get_gender()</span><br><span class="line">&apos;男&apos;</span><br><span class="line">&gt;&gt;&gt; charl.set_gender(&apos;女&apos;)</span><br><span class="line">&gt;&gt;&gt; charl.get_gender()</span><br><span class="line">&apos;女&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承和多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Animal is running......&quot;)</span><br><span class="line">... ... ... </span><br><span class="line">&gt;&gt;&gt; class Dog(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Dog is running......&quot;)</span><br><span class="line"></span><br><span class="line">... ... ... </span><br><span class="line">&gt;&gt;&gt; class Cat(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Cat is running......&quot;)</span><br><span class="line">... ... ... </span><br><span class="line">&gt;&gt;&gt; dog = Dog()</span><br><span class="line">&gt;&gt;&gt; cat = Cat()</span><br><span class="line">&gt;&gt;&gt; dog.run()</span><br><span class="line">Dog is running......</span><br><span class="line">&gt;&gt;&gt; cat.run()</span><br><span class="line">Cat is running......</span><br><span class="line"># isinstance判断变量是否为某个类型</span><br><span class="line">&gt;&gt;&gt; isinstance(cat,Cat)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(dog,Dog)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(cat,Animal)</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"># 多态</span><br><span class="line">&gt;&gt;&gt; def run_twice(animal):</span><br><span class="line">...     animal.run()</span><br><span class="line">...     animal.run()</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; run_twice(dog)</span><br><span class="line">Dog is running......</span><br><span class="line">Dog is running......</span><br><span class="line">&gt;&gt;&gt; run_twice(cat)</span><br><span class="line">Cat is running......</span><br><span class="line">Cat is running......</span><br><span class="line"># 新定义一个Bird类</span><br><span class="line">&gt;&gt;&gt; class Bird(Animal):</span><br><span class="line">...     def run(self):</span><br><span class="line">...         print(&apos;Bird is singing......&apos;)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; bird = Bird()</span><br><span class="line">#无需修改原来的run_twice方法</span><br><span class="line">&gt;&gt;&gt; run_twice(bird)</span><br><span class="line">Bird is singing......</span><br><span class="line">Bird is singing......</span><br><span class="line"></span><br><span class="line">#对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</span><br><span class="line">#对扩展开放：允许新增Animal子类；</span><br><span class="line"></span><br><span class="line">#对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取对象信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 获取对象类型</span><br><span class="line"># 1.type() 不太适用于class的继承结构</span><br><span class="line"># 整型</span><br><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line"># 字符</span><br><span class="line">&gt;&gt;&gt; type(&apos;hello&apos;)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line"># None</span><br><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;class &apos;NoneType&apos;&gt;</span><br><span class="line"># 函数</span><br><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line"># 类</span><br><span class="line">&gt;&gt;&gt; type(dog)</span><br><span class="line">&lt;class &apos;__main__.Dog&apos;&gt;</span><br><span class="line"># 需要借助于types进行判断</span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn()</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    def fn()</span><br><span class="line">           ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; type(fn) == types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 2.isinstance()函数，总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 属性：</span><br><span class="line">#1.使用dir()，获取对象的属性和方法</span><br><span class="line">#2.通过getattr()、setattr()、hasattr()来操作一个对象的状态</span><br><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj,&apos;x&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj,&apos;y&apos;,17)</span><br><span class="line">&gt;&gt;&gt; hasattr(obj,&apos;y&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj,&apos;y&apos;)</span><br><span class="line">17</span><br><span class="line">&gt;&gt;&gt; obj.y</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h3 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h3><ul>
<li>动态绑定属性和方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line"></span><br><span class="line"># 给实例绑定一个属性</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Charl&apos;</span><br><span class="line">&gt;&gt;&gt; print(s.name)</span><br><span class="line">Charl</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line"># 给实例绑定一个方法</span><br><span class="line">&gt;&gt;&gt; def set_age(self,age): # 1.定义一个函数用于绑定</span><br><span class="line">...     self.age = age</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; from types import MethodType # 2.导入MethodType</span><br><span class="line">&gt;&gt;&gt; s.set_age = MethodType(set_age,s) # 3.给实例绑定一个方法</span><br><span class="line">&gt;&gt;&gt; s.set_age(18) # 调用实例方法</span><br><span class="line">&gt;&gt;&gt; s.age #测试结果</span><br><span class="line">18</span><br><span class="line"># 给一个实例绑定的属性，对另一个实例是不起作用的</span><br><span class="line">&gt;&gt;&gt; s1 = Student()</span><br><span class="line">&gt;&gt;&gt; s1.set_age(25)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;set_age&apos;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line"># 给所有实例绑定方法</span><br><span class="line">&gt;&gt;&gt; def set_score(self,score):</span><br><span class="line">...     self.score = score</span><br><span class="line">... </span><br><span class="line"># 给class绑定方法</span><br><span class="line">&gt;&gt;&gt; Student.set_score = set_score</span><br><span class="line">&gt;&gt;&gt; s.set_score(100)</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; s1.set_score(99)</span><br><span class="line">&gt;&gt;&gt; s1.score</span><br><span class="line">99</span><br><span class="line"># 通常,上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<strong>slots</strong>，用于限制类的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     __slots__ = (&apos;name&apos;,&apos;age&apos;) # 使用tuple定义允许绑定的属性名</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Charl&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br><span class="line"></span><br><span class="line">#使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</span><br></pre></td></tr></table></figure>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h3><p>@property装饰器就是负责把一个方法变成属性调用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># 在不用@property之前，为了设置属性，要写的set,get方法和调用起来很复杂</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self._score</span><br><span class="line">    def set_score(self,value):</span><br><span class="line">        if not isinstance(value,int):</span><br><span class="line">            raise ValueError(&apos;score must an int value&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0~100&apos;)</span><br><span class="line">        self._score = value</span><br><span class="line">... ... ... ... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.set_score(100)</span><br><span class="line">&gt;&gt;&gt; s.get_score()</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; s.set_sore(-1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;set_sore&apos;</span><br><span class="line"></span><br><span class="line"># 使用@property 可以把方法编程属性</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    # 相当于getter</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    # 相当于getter</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self,value):</span><br><span class="line">        if not isinstance(value,int):</span><br><span class="line">            raise ValueError(&apos;score must be an int value&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0~100&apos;)</span><br><span class="line">        self._score = value</span><br><span class="line">... ... ... ... ... ... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 100</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; s.score = -1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 10, in score</span><br><span class="line">ValueError: score must between 0~100</span><br><span class="line"></span><br><span class="line"># 可以利用@property定义只读属性</span><br><span class="line"># 下面的birth是一个读写的属性，age是一个只读属性</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self,value):</span><br><span class="line">        self._birth = value</span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2018 - self._birth</span><br><span class="line">... ... ... ... ... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; a = Student()</span><br><span class="line">&gt;&gt;&gt; a.birth = 1993</span><br><span class="line">&gt;&gt;&gt; a.birth</span><br><span class="line">1993</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; a.age</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; a.age = 18</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: can&apos;t set attribute</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># python 支持多重继承,这种设计通常叫做:Mixin,这种设计的目的就是给一个类增加多个功能。</span><br><span class="line">&gt;&gt;&gt; class Dog(Animal,Runable,Flyable):</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><p>python的class中有很多特殊用途的函数，可以帮助我们定制类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1.__str__ 定义class的返回字符串,类似java中的toString()</span><br><span class="line">&gt;&gt;&gt; class Apple(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Apple object (name: %s)&apos; % self.name</span><br><span class="line">... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; print(Apple(&apos;jack&apos;))</span><br><span class="line">Apple object (name: jack)</span><br><span class="line">&gt;&gt;&gt; a = Apple(&apos;hello&apos;)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;__main__.Apple object at 0x000001B816EE4E10&gt;</span><br><span class="line"># 这边不用print 直接打印出来的还是原来的，这是因为直接显示调用的是__repr__()</span><br><span class="line"># 两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串</span><br><span class="line"># 在上面Apple类最后加一行:__repr__ = __str__</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 2.__iter__ 返回一个迭代对象，可以被for...in 调用,即不断调用__next__获取下一个值</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 3.__gettitem__ 获取指定下标的元素，类似于list</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start = 0</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            L = []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return L</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 4.__getattr__ 动态返回一个属性，可以针对动态的情况进行调用</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;Michael&apos;</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;score&apos;:</span><br><span class="line">            return 99</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.name</span><br><span class="line">&apos;Michael&apos;</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">99</span><br><span class="line"># 动态链式调用（根据动态修改）</span><br><span class="line">&gt;&gt;&gt; class Chain(object):</span><br><span class="line">    def __init__(self,path = &apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path,item))</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line">    __repr__ = __str__</span><br><span class="line">... ... ... ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; Chain().user.login.list</span><br><span class="line">/user/login/list</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 5.__call__ 直接调用实例</span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self._name = name</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;ur name is %s:&apos; % self._name)</span><br><span class="line">... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; s = Student(&apos;jack&apos;)</span><br><span class="line">&gt;&gt;&gt; s()</span><br><span class="line">ur name is jack:</span><br><span class="line">通过callable()来判断一个对象是否是‘可调用的’对象</span><br></pre></td></tr></table></figure>
<p>更多的定制方法：<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">https://docs.python.org/3/reference/datamodel.html#special-method-names</a></p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># @unique装饰器可以帮助我们检查保证没有重复值</span><br><span class="line">&gt;&gt;&gt; from enum import Enum,unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2017</span><br><span class="line">&gt;&gt;&gt; ... ... ... ... ... </span><br><span class="line">&gt;&gt;&gt; day1 = Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Mon)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Mon&apos;])</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Mon.value)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(Weekday(0))</span><br><span class="line">Weekday.Sun</span><br></pre></td></tr></table></figure>
<h3 id="元类（这个元类有点类似于Java中的反射）"><a href="#元类（这个元类有点类似于Java中的反射）" class="headerlink" title="元类（这个元类有点类似于Java中的反射）"></a>元类（这个元类有点类似于Java中的反射）</h3><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。元类顾名思义就是可以创建类的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fn(self, name=&apos;world&apos;): # 先定义函数</span><br><span class="line">...     print(&apos;Hello, %s.&apos; % name)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class</span><br><span class="line">&gt;&gt;&gt; h = Hello()</span><br><span class="line">&gt;&gt;&gt; h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line">&gt;&gt;&gt; print(type(Hello))</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print(type(h))</span><br><span class="line">&lt;class &apos;__main__.Hello&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误exception和测试"><a href="#错误exception和测试" class="headerlink" title="错误exception和测试"></a>错误exception和测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1.try机制：</span><br><span class="line">try...</span><br><span class="line">except xxxError as e:</span><br><span class="line">    #有错误的时候执行</span><br><span class="line">    print(&quot;except:&quot;,e)</span><br><span class="line">else:</span><br><span class="line">    #没有错误的时候执行</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    #最后执行</span><br><span class="line">    print(&quot;finally...&quot;)</span><br><span class="line"># 2.定义错误</span><br><span class="line">&gt;&gt;&gt; class FooError(ValueError):</span><br><span class="line">...     pass</span><br><span class="line"># 3.抛出错误</span><br><span class="line">&gt;&gt;&gt; def foo(s):</span><br><span class="line">...     n = int(s)</span><br><span class="line">...     if n == 0:</span><br><span class="line">...         raise FooError(&apos;invalid value haha:%s&apos; % s)</span><br><span class="line">...     return 10/n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; foo(&apos;0&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in foo</span><br><span class="line">__main__.FooError: invalid value haha:0</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/05/MySQL大表优化/" rel="next" title="MySQL大表优化">
                <i class="fa fa-chevron-left"></i> MySQL大表优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">charl</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python基础"><span class="nav-number">1.</span> <span class="nav-text">Python基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串编码"><span class="nav-number">1.2.</span> <span class="nav-text">字符串编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表：List和Tuple"><span class="nav-number">1.3.</span> <span class="nav-text">列表：List和Tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断"><span class="nav-number">1.4.</span> <span class="nav-text">判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环"><span class="nav-number">1.5.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典dict和set"><span class="nav-number">1.6.</span> <span class="nav-text">字典dict和set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python函数"><span class="nav-number">2.</span> <span class="nav-text">Python函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python函数式编程"><span class="nav-number">3.</span> <span class="nav-text">Python函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶函数"><span class="nav-number">3.1.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作为返回值"><span class="nav-number">3.2.</span> <span class="nav-text">函数作为返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数-lambda表示"><span class="nav-number">3.3.</span> <span class="nav-text">匿名函数 lambda表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器-在代码运行期间动态增加功能-类似于Java中的代理模式"><span class="nav-number">3.4.</span> <span class="nav-text">装饰器 在代码运行期间动态增加功能(类似于Java中的代理模式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏函数"><span class="nav-number">3.5.</span> <span class="nav-text">偏函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python模块"><span class="nav-number">4.</span> <span class="nav-text">Python模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程"><span class="nav-number">5.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象高级编程"><span class="nav-number">6.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用slots"><span class="nav-number">6.1.</span> <span class="nav-text">使用slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-property"><span class="nav-number">6.2.</span> <span class="nav-text">使用@property</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">6.3.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定制类"><span class="nav-number">6.4.</span> <span class="nav-text">定制类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类"><span class="nav-number">6.5.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元类（这个元类有点类似于Java中的反射）"><span class="nav-number">6.6.</span> <span class="nav-text">元类（这个元类有点类似于Java中的反射）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误exception和测试"><span class="nav-number">7.</span> <span class="nav-text">错误exception和测试</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">charl</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
